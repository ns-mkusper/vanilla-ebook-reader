// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'engine.dart';
import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'api.freezed.dart';

            // These functions are ignored because they are not marked as `pub`: `backend_model_path`, `dispatch_frames`, `resolve_engine`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`


            Future<void>  initRegistry({required EngineRegistryHandle handle }) => TtsBridge.instance.api.crateApiInitRegistry(handle: handle);

Future<void>  bootstrapDefaultEngine() => TtsBridge.instance.api.crateApiBootstrapDefaultEngine();

Future<TtsState>  currentState() => TtsBridge.instance.api.crateApiCurrentState();

Stream<AudioChunk>  streamAudio({required String text , required EngineRequest request }) => TtsBridge.instance.api.crateApiStreamAudio(text: text, request: request);

            class AudioChunk  {
                final Int16List pcm;
final int sampleRate;
final BigInt startTextIdx;

                const AudioChunk({required this.pcm ,required this.sampleRate ,required this.startTextIdx ,});

                
                

                
        @override
        int get hashCode => pcm.hashCode^sampleRate.hashCode^startTextIdx.hashCode;
        

                
        @override
        bool operator ==(Object other) =>
            identical(this, other) ||
            other is AudioChunk &&
                runtimeType == other.runtimeType
                && pcm == other.pcm&& sampleRate == other.sampleRate&& startTextIdx == other.startTextIdx;
        
            }

@freezed
                sealed class EngineBackend with _$EngineBackend  {
                    const EngineBackend._();

                     const factory EngineBackend.auto({   required String modelPath , }) = EngineBackend_Auto;
 const factory EngineBackend.piper(  PiperBackendConfig field0,) = EngineBackend_Piper;

                    

                    
                }

class EngineRequest  {
                final EngineBackend backend;
final double? gainDb;

                const EngineRequest({required this.backend ,this.gainDb ,});

                
                

                
        @override
        int get hashCode => backend.hashCode^gainDb.hashCode;
        

                
        @override
        bool operator ==(Object other) =>
            identical(this, other) ||
            other is EngineRequest &&
                runtimeType == other.runtimeType
                && backend == other.backend&& gainDb == other.gainDb;
        
            }

class PiperBackendConfig  {
                final String modelPath;
final String? configPath;
final String? speaker;
final int? sampleRate;

                const PiperBackendConfig({required this.modelPath ,this.configPath ,this.speaker ,this.sampleRate ,});

                
                

                
        @override
        int get hashCode => modelPath.hashCode^configPath.hashCode^speaker.hashCode^sampleRate.hashCode;
        

                
        @override
        bool operator ==(Object other) =>
            identical(this, other) ||
            other is PiperBackendConfig &&
                runtimeType == other.runtimeType
                && modelPath == other.modelPath&& configPath == other.configPath&& speaker == other.speaker&& sampleRate == other.sampleRate;
        
            }

class TtsState  {
                final bool isPlaying;
final String currentModel;

                const TtsState({required this.isPlaying ,required this.currentModel ,});

                
                

                
        @override
        int get hashCode => isPlaying.hashCode^currentModel.hashCode;
        

                
        @override
        bool operator ==(Object other) =>
            identical(this, other) ||
            other is TtsState &&
                runtimeType == other.runtimeType
                && isPlaying == other.isPlaying&& currentModel == other.currentModel;
        
            }
            