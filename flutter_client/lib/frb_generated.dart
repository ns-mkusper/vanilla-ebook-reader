// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api.dart';
import 'dart:async';
import 'dart:convert';
import 'engine.dart';
import 'frb_generated.dart';
import 'frb_generated.io.dart' if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';


                /// Main entrypoint of the Rust API
                class TtsBridge extends BaseEntrypoint<TtsBridgeApi, TtsBridgeApiImpl, TtsBridgeWire> {
                  @internal
                  static final instance = TtsBridge._();

                  TtsBridge._();

                  /// Initialize flutter_rust_bridge
                  static Future<void> init({
                    TtsBridgeApi? api,
                    BaseHandler? handler,
                    ExternalLibrary? externalLibrary,
                    bool forceSameCodegenVersion = true,
                  }) async {
                    await instance.initImpl(
                      api: api,
                      handler: handler,
                      externalLibrary: externalLibrary,
                      forceSameCodegenVersion: forceSameCodegenVersion,
                    );
                  }

                  /// Initialize flutter_rust_bridge in mock mode.
                  /// No libraries for FFI are loaded.
                  static void initMock({
                    required TtsBridgeApi api,
                  }) {
                    instance.initMockImpl(
                      api: api,
                    );
                  }

                  /// Dispose flutter_rust_bridge
                  ///
                  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
                  /// is automatically disposed when the app stops.
                  static void dispose() => instance.disposeImpl();

                  @override
                  ApiImplConstructor<TtsBridgeApiImpl, TtsBridgeWire> get apiImplConstructor => TtsBridgeApiImpl.new;

                  @override
                  WireConstructor<TtsBridgeWire> get wireConstructor => TtsBridgeWire.fromExternalLibrary;

                  @override
                  Future<void> executeRustInitializers() async {
                    
                  }

                  @override
                  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig => kDefaultExternalLibraryLoaderConfig;

                  @override
                  String get codegenVersion => '2.11.1';

                  @override
                  int get rustContentHash => 1639405732;

                  static const kDefaultExternalLibraryLoaderConfig = ExternalLibraryLoaderConfig(
                    stem: 'rust_core',
                    ioDirectory: '../rust_core/target/release/',
                    webPrefix: 'pkg/',
                  );
                }
                

                abstract class TtsBridgeApi extends BaseApi {
                  Future<void> crateApiBootstrapDefaultEngine();

Future<TtsState> crateApiCurrentState();

Future<void> crateApiInitRegistry({required EngineRegistryHandle handle });

Stream<AudioChunk> crateApiStreamAudio({required String text , required EngineRequest request });

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_EngineRegistryHandle;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_EngineRegistryHandle;

CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_EngineRegistryHandlePtr;


                }
                

                class TtsBridgeApiImpl extends TtsBridgeApiImplPlatform implements TtsBridgeApi {
                  TtsBridgeApiImpl({
                    required super.handler,
                    required super.wire,
                    required super.generalizedFrbRustBinding,
                    required super.portManager,
                  });

                  @override Future<void> crateApiBootstrapDefaultEngine()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 1, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiBootstrapDefaultEngineConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiBootstrapDefaultEngineConstMeta => const TaskConstMeta(
            debugName: "bootstrap_default_engine",
            argNames: [],
        );
        

@override Future<TtsState> crateApiCurrentState()  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 2, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_tts_state,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiCurrentStateConstMeta,
            argValues: [],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiCurrentStateConstMeta => const TaskConstMeta(
            debugName: "current_state",
            argNames: [],
        );
        

@override Future<void> crateApiInitRegistry({required EngineRegistryHandle handle })  { return handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEngineRegistryHandle(handle, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 3, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiInitRegistryConstMeta,
            argValues: [handle],
            apiImpl: this,
        )); }


        TaskConstMeta get kCrateApiInitRegistryConstMeta => const TaskConstMeta(
            debugName: "init_registry",
            argNames: ["handle"],
        );
        

@override Stream<AudioChunk> crateApiStreamAudio({required String text , required EngineRequest request })  { 
            final sink = RustStreamSink<AudioChunk>();
            unawaited(handler.executeNormal(NormalTask(
            callFfi: (port_) {
              
            final serializer = SseSerializer(generalizedFrbRustBinding);sse_encode_String(text, serializer);
sse_encode_box_autoadd_engine_request(request, serializer);
sse_encode_StreamSink_audio_chunk_Sse(sink, serializer);
            pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 4, port: port_);
            
            },
            codec: 
        SseCodec(
          decodeSuccessData: sse_decode_unit,
          decodeErrorData: null,
        )
        ,
            constMeta: kCrateApiStreamAudioConstMeta,
            argValues: [text, request, sink],
            apiImpl: this,
        )));
            return sink.stream;
             }


        TaskConstMeta get kCrateApiStreamAudioConstMeta => const TaskConstMeta(
            debugName: "stream_audio",
            argNames: ["text", "request", "sink"],
        );
        

RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_EngineRegistryHandle => wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEngineRegistryHandle;

RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_EngineRegistryHandle => wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEngineRegistryHandle;



                  @protected AnyhowException dco_decode_AnyhowException(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return AnyhowException(raw as String); }

@protected EngineRegistryHandle dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEngineRegistryHandle(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return EngineRegistryHandleImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected EngineRegistryHandle dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEngineRegistryHandle(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return EngineRegistryHandleImpl.frbInternalDcoDecode(raw as List<dynamic>); }

@protected RustStreamSink<AudioChunk> dco_decode_StreamSink_audio_chunk_Sse(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
throw UnimplementedError(); }

@protected String dco_decode_String(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as String; }

@protected AudioChunk dco_decode_audio_chunk(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 3) throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
                return AudioChunk(pcm: dco_decode_list_prim_i_16_strict(arr[0]),
sampleRate: dco_decode_u_32(arr[1]),
startTextIdx: dco_decode_usize(arr[2]),); }

@protected bool dco_decode_bool(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as bool; }

@protected EngineRequest dco_decode_box_autoadd_engine_request(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_engine_request(raw); }

@protected double dco_decode_box_autoadd_f_32(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as double; }

@protected PiperBackendConfig dco_decode_box_autoadd_piper_backend_config(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dco_decode_piper_backend_config(raw); }

@protected int dco_decode_box_autoadd_u_32(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as int; }

@protected EngineBackend dco_decode_engine_backend(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
switch (raw[0]) {
                case 0: return EngineBackend_Auto(modelPath: dco_decode_String(raw[1]),);
case 1: return EngineBackend_Piper(dco_decode_box_autoadd_piper_backend_config(raw[1]),);
                default: throw Exception("unreachable");
            } }

@protected EngineRequest dco_decode_engine_request(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
                return EngineRequest(backend: dco_decode_engine_backend(arr[0]),
gainDb: dco_decode_opt_box_autoadd_f_32(arr[1]),); }

@protected double dco_decode_f_32(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as double; }

@protected int dco_decode_i_16(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as int; }

@protected Int16List dco_decode_list_prim_i_16_strict(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as Int16List; }

@protected Uint8List dco_decode_list_prim_u_8_strict(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as Uint8List; }

@protected String? dco_decode_opt_String(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_String(raw); }

@protected double? dco_decode_opt_box_autoadd_f_32(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_f_32(raw); }

@protected int? dco_decode_opt_box_autoadd_u_32(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw == null ? null : dco_decode_box_autoadd_u_32(raw); }

@protected PiperBackendConfig dco_decode_piper_backend_config(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 4) throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
                return PiperBackendConfig(modelPath: dco_decode_String(arr[0]),
configPath: dco_decode_opt_String(arr[1]),
speaker: dco_decode_opt_String(arr[2]),
sampleRate: dco_decode_opt_box_autoadd_u_32(arr[3]),); }

@protected TtsState dco_decode_tts_state(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
final arr = raw as List<dynamic>;
                if (arr.length != 2) throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
                return TtsState(isPlaying: dco_decode_bool(arr[0]),
currentModel: dco_decode_String(arr[1]),); }

@protected int dco_decode_u_32(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as int; }

@protected int dco_decode_u_8(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return raw as int; }

@protected void dco_decode_unit(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return; }

@protected BigInt dco_decode_usize(dynamic raw){ // Codec=Dco (DartCObject based), see doc to use other codecs
return dcoDecodeU64(raw); }

@protected AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_String(deserializer);
        return AnyhowException(inner); }

@protected EngineRegistryHandle sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEngineRegistryHandle(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return EngineRegistryHandleImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected EngineRegistryHandle sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEngineRegistryHandle(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return EngineRegistryHandleImpl.frbInternalSseDecode(sse_decode_usize(deserializer), sse_decode_i_32(deserializer)); }

@protected RustStreamSink<AudioChunk> sse_decode_StreamSink_audio_chunk_Sse(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
throw UnimplementedError('Unreachable ()'); }

@protected String sse_decode_String(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var inner = sse_decode_list_prim_u_8_strict(deserializer);
        return utf8.decoder.convert(inner); }

@protected AudioChunk sse_decode_audio_chunk(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_pcm = sse_decode_list_prim_i_16_strict(deserializer);
var var_sampleRate = sse_decode_u_32(deserializer);
var var_startTextIdx = sse_decode_usize(deserializer);
return AudioChunk(pcm: var_pcm, sampleRate: var_sampleRate, startTextIdx: var_startTextIdx); }

@protected bool sse_decode_bool(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getUint8() != 0; }

@protected EngineRequest sse_decode_box_autoadd_engine_request(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_engine_request(deserializer)); }

@protected double sse_decode_box_autoadd_f_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_f_32(deserializer)); }

@protected PiperBackendConfig sse_decode_box_autoadd_piper_backend_config(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_piper_backend_config(deserializer)); }

@protected int sse_decode_box_autoadd_u_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return (sse_decode_u_32(deserializer)); }

@protected EngineBackend sse_decode_engine_backend(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            var tag_ = sse_decode_i_32(deserializer);
            switch (tag_) { case 0: var var_modelPath = sse_decode_String(deserializer);
return EngineBackend_Auto(modelPath: var_modelPath);case 1: var var_field0 = sse_decode_box_autoadd_piper_backend_config(deserializer);
return EngineBackend_Piper(var_field0); default: throw UnimplementedError(''); }
             }

@protected EngineRequest sse_decode_engine_request(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_backend = sse_decode_engine_backend(deserializer);
var var_gainDb = sse_decode_opt_box_autoadd_f_32(deserializer);
return EngineRequest(backend: var_backend, gainDb: var_gainDb); }

@protected double sse_decode_f_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getFloat32(); }

@protected int sse_decode_i_16(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getInt16(); }

@protected Int16List sse_decode_list_prim_i_16_strict(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var len_ = sse_decode_i_32(deserializer);
                return deserializer.buffer.getInt16List(len_); }

@protected Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var len_ = sse_decode_i_32(deserializer);
                return deserializer.buffer.getUint8List(len_); }

@protected String? sse_decode_opt_String(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_String(deserializer));
            } else {
                return null;
            }
             }

@protected double? sse_decode_opt_box_autoadd_f_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_f_32(deserializer));
            } else {
                return null;
            }
             }

@protected int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs

            if (sse_decode_bool(deserializer)) {
                return (sse_decode_box_autoadd_u_32(deserializer));
            } else {
                return null;
            }
             }

@protected PiperBackendConfig sse_decode_piper_backend_config(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_modelPath = sse_decode_String(deserializer);
var var_configPath = sse_decode_opt_String(deserializer);
var var_speaker = sse_decode_opt_String(deserializer);
var var_sampleRate = sse_decode_opt_box_autoadd_u_32(deserializer);
return PiperBackendConfig(modelPath: var_modelPath, configPath: var_configPath, speaker: var_speaker, sampleRate: var_sampleRate); }

@protected TtsState sse_decode_tts_state(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
var var_isPlaying = sse_decode_bool(deserializer);
var var_currentModel = sse_decode_String(deserializer);
return TtsState(isPlaying: var_isPlaying, currentModel: var_currentModel); }

@protected int sse_decode_u_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getUint32(); }

@protected int sse_decode_u_8(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getUint8(); }

@protected void sse_decode_unit(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
 }

@protected BigInt sse_decode_usize(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getBigUint64(); }

@protected int sse_decode_i_32(SseDeserializer deserializer){ // Codec=Sse (Serialization based), see doc to use other codecs
return deserializer.buffer.getInt32(); }

@protected void sse_encode_AnyhowException(AnyhowException self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.message, serializer); }

@protected void sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEngineRegistryHandle(EngineRegistryHandle self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as EngineRegistryHandleImpl).frbInternalSseEncode(move: true), serializer); }

@protected void sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerEngineRegistryHandle(EngineRegistryHandle self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_usize((self as EngineRegistryHandleImpl).frbInternalSseEncode(move: null), serializer); }

@protected void sse_encode_StreamSink_audio_chunk_Sse(RustStreamSink<AudioChunk> self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.setupAndSerialize(codec: SseCodec(
            decodeSuccessData: sse_decode_audio_chunk,
            decodeErrorData: sse_decode_AnyhowException,
        )), serializer); }

@protected void sse_encode_String(String self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer); }

@protected void sse_encode_audio_chunk(AudioChunk self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_list_prim_i_16_strict(self.pcm, serializer);
sse_encode_u_32(self.sampleRate, serializer);
sse_encode_usize(self.startTextIdx, serializer);
 }

@protected void sse_encode_bool(bool self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putUint8(self ? 1 : 0); }

@protected void sse_encode_box_autoadd_engine_request(EngineRequest self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_engine_request(self, serializer); }

@protected void sse_encode_box_autoadd_f_32(double self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_f_32(self, serializer); }

@protected void sse_encode_box_autoadd_piper_backend_config(PiperBackendConfig self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_piper_backend_config(self, serializer); }

@protected void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_u_32(self, serializer); }

@protected void sse_encode_engine_backend(EngineBackend self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
switch (self) { case EngineBackend_Auto(modelPath: final modelPath): sse_encode_i_32(0, serializer); sse_encode_String(modelPath, serializer);
case EngineBackend_Piper(field0: final field0): sse_encode_i_32(1, serializer); sse_encode_box_autoadd_piper_backend_config(field0, serializer);
  } }

@protected void sse_encode_engine_request(EngineRequest self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_engine_backend(self.backend, serializer);
sse_encode_opt_box_autoadd_f_32(self.gainDb, serializer);
 }

@protected void sse_encode_f_32(double self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putFloat32(self); }

@protected void sse_encode_i_16(int self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putInt16(self); }

@protected void sse_encode_list_prim_i_16_strict(Int16List self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
                    serializer.buffer.putInt16List(self); }

@protected void sse_encode_list_prim_u_8_strict(Uint8List self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_i_32(self.length, serializer);
                    serializer.buffer.putUint8List(self); }

@protected void sse_encode_opt_String(String? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_String(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_f_32(double? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_f_32(self, serializer);
                }
                 }

@protected void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs

                sse_encode_bool(self != null, serializer);
                if (self != null) {
                    sse_encode_box_autoadd_u_32(self, serializer);
                }
                 }

@protected void sse_encode_piper_backend_config(PiperBackendConfig self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_String(self.modelPath, serializer);
sse_encode_opt_String(self.configPath, serializer);
sse_encode_opt_String(self.speaker, serializer);
sse_encode_opt_box_autoadd_u_32(self.sampleRate, serializer);
 }

@protected void sse_encode_tts_state(TtsState self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
sse_encode_bool(self.isPlaying, serializer);
sse_encode_String(self.currentModel, serializer);
 }

@protected void sse_encode_u_32(int self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putUint32(self); }

@protected void sse_encode_u_8(int self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putUint8(self); }

@protected void sse_encode_unit(void self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
 }

@protected void sse_encode_usize(BigInt self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putBigUint64(self); }

@protected void sse_encode_i_32(int self, SseSerializer serializer){ // Codec=Sse (Serialization based), see doc to use other codecs
serializer.buffer.putInt32(self); }
                }
                

            @sealed class EngineRegistryHandleImpl extends RustOpaque implements EngineRegistryHandle {
                // Not to be used by end users
                EngineRegistryHandleImpl.frbInternalDcoDecode(List<dynamic> wire):
                    super.frbInternalDcoDecode(wire, _kStaticData);

                // Not to be used by end users
                EngineRegistryHandleImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative):
                    super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

                static final _kStaticData = RustArcStaticData(
                    rustArcIncrementStrongCount: TtsBridge.instance.api.rust_arc_increment_strong_count_EngineRegistryHandle,
                    rustArcDecrementStrongCount: TtsBridge.instance.api.rust_arc_decrement_strong_count_EngineRegistryHandle,
                    rustArcDecrementStrongCountPtr: TtsBridge.instance.api.rust_arc_decrement_strong_count_EngineRegistryHandlePtr,
                );

                
            }